#!/bin/bash -x
#===============================================================================
#
#          FILE: deploy.sh
#
#         USAGE: ./deploy.sh
#
#   DESCRIPTION:  deployer
#
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Fernando Augusto Medeiros Silva (), fams@linuxplace.com.br
#  ORGANIZATION: Linuxplace
#       CREATED: 28/04/2020 21:56
#      REVISION: 29/05/2020 23:07
#===============================================================================

set -o nounset                              # Treat unset variables as an error

LOCAL_PATH_CHART=./curr_chart

DEBUG=1

function init(){
  # atribui a chave para conseguir clonar repos
  mkdir ~/.ssh
  ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
  echo "$SSH_PRIVATE_KEY" >> ~/.ssh/id_rsa && chmod 0600 ~/.ssh/id_rsa
}

function fetchChart(){
  # clona o helm chart template
  CHART_REPO=$1
  BRANCH=$2
  git clone $CHART_REPO -b ${BRANCH} ${LOCAL_PATH_CHART}
}

# constroi array associativo RELEASE_STATUS com dados do release.
function buildReleaseStatus(){
    deployment_name=$1
    release_status=$(helm --namespace ${NAMESPACE} status "${deployment_name}" -o json 2>&1)

    # Determinando se o comando funcionou
    if echo $release_status | grep "Error" >/dev/null ; then
      RELEASE_STATUS[error]="true";
      RELEASE_STATUS[error_desc]=$(echo $release_status |sed -e 's/Error: //')
      # se o erro foi de release não encontrada, retornando 1
      if [ "${RELEASE_STATUS[error_desc]}" == "release: not found" ]; then
        return 1
      else
      # Qualuer outro erro, por enquanto 2
        return 2
      fi
    else
      RELEASE_STATUS[error]="false";
      RELEASE_STATUS[status]=${release_status}
    fi
}

# constroi array associativo DEPLOYMENT_STATUS com dados do release.
function buildDeploymentStatus(){
    set -x
    deployment_name=$1
    deploy_status=$($KN get deploy "${deployment_name}" -o json 2>&1)
    set +x
    # Determinando se o comando funcionou
    if echo $deploy_status | grep "^Error" >/dev/null ; then
      DEPLOYMENT_STATUS[error]="true";
      DEPLOYMENT_STATUS[error_desc]=$(echo $release_status |sed -e 's/^Error//')
      # se o erro foi de release não encontrada, retornando 1
      if echo -E "${DEPLOYMENT_STATUS[error_desc]}" |grep "deployments.extensions \"${deployment_name}\" not found" ; then
        return 1
      else
      # Qualuer outro erro, por enquanto 2
        return 2
      fi
    else
      DEPLOYMENT_STATUS[error]="false";
      DEPLOYMENT_STATUS[status]=${deploy_status}
    fi
}

function getLastPod(){
  rsname=$1
  num=-1
  IFS=''
  # GET=false
  while read line ;do
    # $GET && echo ${line}
    if (echo ${line} | grep "Normal.*SuccessfulCreate" >/dev/null); then
      created_pod=$(echo ${line} | awk '{print $7}');
      # GET=true
    fi
    if (echo ${line} | grep "Normal.*SuccessfulDelete" >/dev/null); then
      deleted_pod=$(echo ${line} | awk '{print $7}');
      if [ "${created_pod}" == "${deployment_name}" ]; then
        created_pod=""
      fi
    fi
  done <  <( $KN describe rs $rsname )
  echo $created_pod
}
function showPodLog(){
  rsname=$1
  while true; do
    pod=$(getLastPod rsname)
    if [ ! -z "${pod}" ] ;then
      $KN logs ${pod} -f
    fi
  done
}
# Verifica se o deploy funcionou
# Toda essa função está errada e deve ser utilizado o kubectl rollout pra monitorar o rollout :-(
function wait_for_deploy(){
  deployment_name=$1
  new_rs_name=$($KN describe ${deployment_name} |grep NewReplicaSet|awk '{print $2}')
  (showPodLog $new_rs_name )&
  LOG_PID=$!
  kubectl rollout $deployment_name --timeout  $DEPLOY_TIMEOUT
  kill $LOG_PID
  # buildDeploymentStatus $deployment_name
  # ret=$?
  # if [ "$ret" -ne 0 ]; then
  #   echo "${deployment_name} não encontrado"
  #   return 1
  # fi

  # count=0
  # # Executa x vezes dependendo do timeout e do intervalo declarado
  # limit=$((DEPLOY_TIMEOUT/DEPLOY_INTERVAL))

  # while  [ "$count" -lt "$limit" ] ; do
  #     buildDeploymentStatus $deployment_name
  #     # Se deployment ok return ok
  #     if getDeployParam 'status.conditions[1].message' | grep "successfully progressed" >/dev/null 2>&1 ; then
  #       return 0
  #     fi
  #     echo "waiting  for $count of $limit"
  #     sleep ${DEPLOY_INTERVAL}

  #     #Verifica multiplos erros


  #     count=$((count+1))
  # done
  # return 1
}

function getPodDecribe(){
      deployment_name=$1
      #Verifica multiplos erros
      replicaset=$($KN describe deploy "${deployment_name}" |grep NewReplicaSet|awk '{print $2}')
      pod=$($KN get pods  -o json | jq -r '
          .items[]
          |select (.metadata.ownerReferences[].name=="'$replicaset'")
          |.metadata.name'|tail -n1)
      $KN describe pod $pod
}

# Le o Manifesto publicado

function readManifest(){
  release_name=$1

  num=-1
  IFS=''
  set +x
  while read line ;do
    if (echo ${line} | grep "^---$" >/dev/null); then
      num=$((num+1))
      MANIFEST[$num]=""
    else
      MANIFEST[$num]="${MANIFEST[${num}]}\n${line}"
    fi
  done <  <(helm -n ${NAMESPACE} get manifest ${release_name} )
  set -x
}

function getManifestParam(){
  set +x
  param=$1
  kind=${2:-Deployment}
  for ((i=0;i<${#MANIFEST[@]};i++)); do
    echo -e ${MANIFEST[${i}]} |yq -r .kind |grep $kind
    ret=$?
    if [ "$ret" -ne 0 ]; then
      continue
    fi
    echo -e ${MANIFEST[${i}]} |yq -r .${param}
  done
  set -x
}
function getDeployParam(){
  param=$1
  echo -E ${DEPLOYMENT_STATUS[status]} | jq -r .${param}
}

function getReleaseParam(){
  param=$1
  echo -E ${RELEASE_STATUS[status]} | jq -r .${param}
}

function getChartParam(){
  param=$1
  cat ${LOCAL_PATH_CHART}/Chart.yaml | yq -r .${param}
}

function getAppProperties(){
  param=$1
  cat $APP_PROPERTIES | yq -r .${param}
}

function buildReleaseName(){
  RELEASE_NAME_OVERRIDE=${RELEASE_NAME_OVERRIDE:-}
  if [ ! -z "${RELEASE_NAME_OVERRIDE}" ] ; then
    return ${RELEASE_NAME_OVERRIDE}
  fi
  chart_name=$(getChartParam name)
  release_suffix=${RELEASE_SUFFIX:-${chart_name}}
  app_name=$(getAppProperties basename)
  api_version=$(getAppProperties apiVersion)
  echo "${api_version}-${app_name}-${release_suffix}"
}

function buildValues(){
  app_name=$1
  cat <<EOF
image:
  repository: ${REPOSITORY}
  tag: "${TAG}"
AwsAccountId: "${AWS_ACCOUNT_ID}"
cd:
  commit: "${CI_COMMIT_SHORT_SHA:-none}"
  branch: ${CI_DEFAULT_BRANCH:-none}
  basename: ${app_name}
  reponame: $(echo ${CI_PROJECT_URL:-none}|sed -Ee 's/https|http|:|\///g')
  group: ${GROUP_NAME:-none}
EOF
}

function helmdeploy(){
  #FIXME checar se o chart está ok

  release_name=$(buildReleaseName)
  buildReleaseStatus $release_name; ret=$?
  app_name=$(getAppProperties basename)
  groupname=$(getAppProperties groupname)
  name_override=""
  if [ ! -z "$app_name" ];then
    name_override="--set-string nameOverride=${app_name}"
  fi

  echo "Template a ser executado"
  #fixme trocar caminho do values
  buildValues $app_name
  buildValues $app_name > ./ci.values
  helm template -f ./ci.values  -f ./kubernetes/values.yaml $release_name ${LOCAL_PATH_CHART} --namespace ${NAMESPACE}

  if [ "$(getReleaseParam info.status)" == "failed" ];then
    helm delete --purge "$app_name"
  fi
  helm upgrade --install -f ./ci.values  -f ./kubernetes/values.yaml $release_name ${LOCAL_PATH_CHART} --namespace ${NAMESPACE} --wait --timeout $HELM_TIMEOUT

  readManifest ${release_name}

  if wait_for_deploy $(getManifestParam metadata.name) $(getReleaseParam version) ; then
    echo "Deployment successfull!"
    echo "Status:"
    getDeployParam status
    getPodDecribe $(getManifestParam metadata.name)
    return 0
  else
    echo "Deployment Fail"
    echo "Last Status:"
    getDeployParam status
    return 1
  fi

}

function dispHelp(){
cat <<EOF
$0 command [params]

commands:
  init
  fetchchart -c <charturi>
  deploy -i <imagename> -n <namespace> -r <deployment_name>

 -h help
EOF

}
#### starts here

declare -A RELEASE_STATUS
declare -A DEPLOYMENT_STATUS
declare DEPLOY_TIMEOUT=60s
declare HELM_TIMEOUT=20s
declare DEPLOY_INTERVAL=5
declare -a MANIFEST

#### comandos
if [ $# -lt 1 ] ; then
  dispHelp
  exit 1
fi


VERB=$1
shift
while getopts i:n:c:b:r:o:s:a:h OPCAO; do
     case "${OPCAO}" in
        # imagem docker
        i) IMAGENAME="${OPTARG}" ;;
        # override release name
        r) RELEASE_NAME_OVERRIDE="${OPTARG}" ;;
        # HELM CHART REPO
        c) CHART_REPO="${OPTARG}" ;;
        # HELM CHART BRANCH
        b) CHART_BRANCH="${OPTARG}";;
        # RELEASE SUFFIX
        o) RELEASE_SUFFIX="${OPTARG}";;
        # NAMESPACE TO DEPLOY
        n) NAMESPACE="${OPTARG}" ;;
        # SSH KEY OVERRIDE
        s) SSH_OPT="${OPTARG}" ;;
        a) APP_PROPERTIES="${OPTARG}" ;;
        h) dispHelp; exit ;;

     esac
done

#Init Vars

# Namespace
NAMESPACE="${NAMESPACE:-${CI_ENVIRONMENT_SLUG}}"
export NAMESPACE
echo Running in ${NAMESPACE}

KN="kubectl -n $NAMESPACE"
# Get AwsAccount running
export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
echo Running in ${AWS_ACCOUNT_ID}

#SSH PRIVATEKEY
SSH_PRIVATE_KEY=${SSH_OPT:-${SSH_PRIVATE_KEY}}

IMAGENAME=${IMAGENAME:-none:none}
TAG=$(echo $IMAGENAME |cut -f2 -d:)
REPOSITORY=$(echo $IMAGENAME |cut -f1 -d:)

if [ ! -f APP_PROPERTIES ]; then
  APP_PROPERTIES="./kubernetes/app.properties.yaml"
fi
case "$VERB" in
  init)
    init
  ;;
  fetchchart)
    fetchChart $CHART_REPO ${CHART_BRANCH:-master}
  ;;
  deploy)
    helmdeploy
  ret=$?
  exit $ret
  ;;
  *)
  echo "Comando invalido ${VERB}"
    exit 1
  ;;
esac
