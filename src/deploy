#!/bin/bash
#===============================================================================
#
#          FILE: deploy.sh
#
#         USAGE: ./deploy.sh
#
#   DESCRIPTION:  deployer
#
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Fernando Augusto Medeiros Silva (), fams@linuxplace.com.br
#  ORGANIZATION: Linuxplace
#       CREATED: 28/04/2020 21:56
#      REVISION:  ---
#===============================================================================

set -o nounset                              # Treat unset variables as an error

TMP_CHART=./curr_chart

function init(){
  # atribui a chave para conseguir clonar repos
  mkdir ~/.ssh
  ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
  echo "$SSH_PRIVATE_KEY" >> ~/.ssh/id_rsa && chmod 0600 ~/.ssh/id_rsa
}

function fetchChart(){
  # clona o helm chart template
  CHART_REPO=$1
  BRANCH=$2
  git clone $CHART_REPO -b ${BRANCH} ${TMP_CHART}
}

# constroi array associativo RELEASE_STATUS com dados do release.
function buildReleaseStatus(){
    deployment_name=$1
    release_status=$(helm --namespace ${NAMESPACE} status "${deployment_name}" -o json 2>&1)

    # Determinando se o comando funcionou
    if echo $release_status | grep "Error" >/dev/null ; then
      RELEASE_STATUS[error]="true";
      RELEASE_STATUS[error_desc]=$(echo $release_status |sed -e 's/Error: //')
      # se o erro foi de release não encontrada, retornando 1
      if [ "${RELEASE_STATUS[error_desc]}" == "release: not found" ]; then
        return 1
      else
      # Qualuer outro erro, por enquanto 2
        return 2
      fi
    else
      RELEASE_STATUS[error]="false";
      RELEASE_STATUS[status]=${release_status}
    fi
}

# constroi array associativo DEPLOYMENT_STATUS com dados do release.
function buildDeploymentStatus(){

    deployment_name=$1
    deploy_status=$(kubectl -n ${NAMESPACE} get deploy "${deployment_name}" -o json 2>&1)

    # Determinando se o comando funcionou
    if echo $deploy_status | grep "^Error" >/dev/null ; then
      DEPLOYMENT_STATUS[error]="true";
      DEPLOYMENT_STATUS[error_desc]=$(echo $release_status |sed -e 's/^Error//')
      # se o erro foi de release não encontrada, retornando 1
      if echo -E "${DEPLOYMENT_STATUS[error_desc]}" |grep "deployments.extensions \"${deployment_name}\" not found" ; then
        return 1
      else
      # Qualuer outro erro, por enquanto 2
        return 2
      fi
    else
      DEPLOYMENT_STATUS[error]="false";
      DEPLOYMENT_STATUS[status]=${deploy_status}
    fi
}

# Verifica se o deploy funcionou
# Toda essa função está errada e deve ser utilizado o kubectl rollout pra monitorar o rollout :-(
function wait_for_deploy(){
  deployment_name=$1

  buildDeploymentStatus $deployment_name

  count=0
  # Executa x vezes dependendo do timeout e do intervalo declarado
  limit=$((DEPLOY_TIMEOUT/DEPLOY_INTERVAL))

  while  [ "$count" -lt "$limit" ] ; do
      buildDeploymentStatus $deployment_name
      # Se deployment ok return ok
      if getDeployParam 'status.conditions[1].message' | grep "successfully progressed" >/dev/null 2>&1 ; then
        return 0
      fi
      echo "waiting  for $count of $limit"
      sleep ${DEPLOY_INTERVAL}

      #Verifica multiplos erros


      count=$((count+1))
  done
  return 1
}

function getPodDecribe(){
      deployment_name=$1
      #Verifica multiplos erros
      replicaset=$(kubectl -n ${NAMESPACE} describe deploy "${deployment_name}" |grep NewReplicaSet|awk '{print $2}')
      pod=$(kubectl -n ${NAMESPACE} get pods  -o json | jq -r '
          .items[]
          |select (.metadata.ownerReferences[].name=="'$replicaset'")
          |.metadata.name'|tail -n1)
      kubectl -n ${NAMESPACE} describe pod $pod
}

# Le o Manifesto publicado

function readManifest(){
  release_name=$1

  num=-1
  IFS=''
  while read line ;do
    if (echo ${line} | grep "^---$" >/dev/null); then
      num=$((num+1))
      MANIFEST[$num]=""
    else
      MANIFEST[$num]="${MANIFEST[${num}]}\n${line}"
    fi
  done <  <(helm -n ${NAMESPACE} get manifest ${release_name} )
}

function getManifestParam(){
  param=$1
  echo -e ${MANIFEST[0]} |yq -r .${param}
}
function getDeployParam(){
  param=$1
  echo -E ${DEPLOYMENT_STATUS[status]} | jq -r .${param}
}

function getReleaseParam(){
  param=$1
  echo -E ${RELEASE_STATUS[status]} | jq -r .${param}
}

function helmdeploy(){
  image_tag=$1
  release_name=$2

  buildReleaseStatus $release_name; ret=$?

  echo "Template a ser executado"
  helm template --set image.repository=${image_tag} --set-string AwsAccountId=${AWS_ACCOUNT_ID} -f values.yaml $release_name ${TMP_CHART} --namespace ${NAMESPACE}

  # 0 nao encontrou release
  # 1 Encontrou release
  # 2 Erro helm
  case $ret in
    1)
      operation=install
      #install
      echo "Instalando $release_name com imagem=${image_tag} namespace=${NAMESPACE}"
      helm install --set image.repository=${image_tag} --set-string AwsAccountId=${AWS_ACCOUNT_ID} -f values.yaml $release_name ${TMP_CHART} --namespace ${NAMESPACE}
      ;;
    0)
      operation=update
      echo "Atualizando $deployment_name com imagem=${image_tag} namespace=${NAMESPACE}"
      helm upgrade --set image.repository=${image_tag} --set-string AwsAccountId=${AWS_ACCOUNT_ID} -f values.yaml $release_name ${TMP_CHART} --namespace ${NAMESPACE}
    ;;
    *)
      operation=error
      echo "Erro executando helm ${RELEASE_STATUS[error_desc]}"
      exit 1
    ;;
  esac

  readManifest ${release_name}


  if wait_for_deploy $(getManifestParam metadata.name) $(getReleaseParam version) ; then
    echo "Deployment successfull!"
    echo "Status:"
    getDeployParam status
    getPodDecribe $(getManifestParam metadata.name)
    return 0
  else
    echo "Deployment Fail"
    echo "Last Status:"
    getDeployParam status
    return 1
  fi

}

function dispHelp(){
cat <<EOF
$0 command [params]

commands:
  init
  fetchchart -c <charturi>
  deploy -i <imagename> -n <namespace> -r <deployment_name>

 -h help
EOF

}
#### starts here

declare -A RELEASE_STATUS
declare -A DEPLOYMENT_STATUS
declare DEPLOY_TIMEOUT=300
declare DEPLOY_INTERVAL=5
declare -a MANIFEST

#### comandos
if [ $# -lt 1 ] ; then
  dispHelp
  exit 1
fi


VERB=$1
shift
while getopts i:n:c:b:r:h OPCAO; do
     case "${OPCAO}" in
        i) IMAGENAME="${OPTARG}" ;;
        r) RELEASE_NAME="${OPTARG}" ;;
        c) CHART_REPO="${OPTARG}" ;;
        b) BRANCH="${OPTARG}";;
        n) NAMESPACE="${OPTARG}" ;;
        h) dispHelp; exit ;;
     esac
done

if [ ! -z "${NAMESPACE:-}" ];then
  export NAMESPACE
  echo Running in ${NAMESPACE}
else
  export NAMESPACE=$CI_ENVIRONMENT_SLUG
fi

# Get AwsAccount running
export AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
echo Running in ${AWS_ACCOUNT_ID}

case "$VERB" in
  init)
    init
  ;;
  fetchchart)
    fetchChart $CHART_REPO ${BRANCH:-master}
  ;;
  deploy)
    helmdeploy ${IMAGENAME} ${RELEASE_NAME}-master ${NAMESPACE}
  ret=$?
  exit $ret
  ;;
  *)
  echo "Comando invalido $VERB"
    exit 1
  ;;
esac
